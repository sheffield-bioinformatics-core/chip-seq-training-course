---
title: "Chip-seq in Galaxy and R"
author: "Emily Chambers"
date: '`r format(Sys.time(), "Last modified: %d %b %Y")`'
output: 
  html_notebook: 
    toc: yes
    toc_float: yes
    css: stylesheets/styles.css
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,message=FALSE)
```
# Hands-on chip-seq Analysis in Galaxy and R

### Sheffield Bioinformatics Core
<img src="images/logo-sm.png" align=right>

web : [sbc.shef.ac.uk](http://sbc.shef.ac.uk)  
twitter: [SheffBioinfCore](https://twitter.com/SheffBioinfCore)  
email: [bioinformatics-core@sheffield.ac.uk](bioinformatics-core@sheffield.ac.uk)

-----

# Acknowledgement

Some of these materials are based on courses available at .

- [ATAC-Seq data analysis in Galaxy](https://training.galaxyproject.org/training-material/topics/epigenetics/tutorials/atac-seq/tutorial.html/)
- [Chip-seq excersizes in R by Jonas Ibn-Salem, JGU Mainz](http://cbdm-01.zdv.uni-mainz.de/~jibnsale/teaching/chip-seq_exercises.html)
- [The ChIPpeakAnno user’s guide by Jianhong Ou, Jun Yu, Lihua Julie Zhu](https://www.bioconductor.org/packages/release/bioc/vignettes/ChIPpeakAnno/inst/doc/ChIPpeakAnno.html)

-----

# Tutorial overview
This tutorial will continue the analysis of the ChIP-seq peak data that we squired in part 1. Let's have another look at our workflow. We now have our chip-seq peaks called in a bed file and are ready for our downstream analysis.



![](images/park_workflow.jpg)

For the purposes of looking at peak annotation and enrichments we will look at the complete peak data for the breast cancer dataset. In part 1 we examined a smaller subset of this data in order to carry out alignments and peak calling within a shorter time frame. The next part of our analysis involves annotating our peaks, carrying out a differential peak enrichment analysis and visualisations.


# Working in Rstudio

For the second part of the analysis we will move onto using the R programming language in RStudio. R is a very useful tool for quickly manipulating and visualising biological data and will allow us to visualise, annotate and investigate our peak data. You can get more information on R and the Sheffield Bioinformatics Core online training materials [here](https://sbc.shef.ac.uk/training/r-introduction-2020-03-03/).

Organising your R analyses into project is good practice for keeping all files relevant to a particular piece of work in one place. Open up RStudio and create a new project:

<div class="information">

**File > New Project > Existing Directory > …choose workshop material directory**

</div>

We’ve now turned our workshop material folder into an Rstudio project and launched it.

We’ll also be carrying out our analysis  in an R Notebook which allow us keep each R code in executable chunks with output visible immediately beneath the input.

Let’s open an R Notebook to start work in.

<div class="information">

**File > New File > R notebook**

</div>

# Required R packages
In this afternoons analysis we will need to use several R packages. If you have not already done so, please install the packages we will need for the analysis using the code below.

```{r}
if(!require(ChIPpeakAnno)) BiocManager::install("ChIPpeakAnno")
if(!require(TxDb.Hsapiens.UCSC.hg18.knownGene)) BiocManager::install("TxDb.Hsapiens.UCSC.hg18.knownGene")
if(!require(org.Hs.eg.db))BiocManager::install("org.Hs.eg.db")
if(!require(dplyr)) BiocManager::install("dplyr")
if(!require(rtracklayer)) BiocManager::install("rtracklayer")
if(!require(reactome.db)) BiocManager::install("reactome.db")

```

# Upload Data

Once we have the packages downloaded, we can upload our MACS2 peak bed files that we downloaded from galaxy. We will first open the readr package, which allows us to import spreadsheets (like our bed file!) into R

```{r}
FOXA1_df <- read.table("data/FOXA1_full.bed", header=TRUE)
head(FOXA1_df)

```


# Convert peaks into a GRanges object
A GRanges object form the GenomicRanges packages is a container for genomic locations and their associated annotations. We will use this data structure for the ChIP-seq peak coordinates.
```{r}
library(GenomicRanges) # load the GenomicRanges pakcage

FOXA1 <- GRanges(
  FOXA1_df$chr,
  IRanges(FOXA1_df$start, FOXA1_df$end),
  strand="*"
)

# we can add more data to each peak subsequently
names(FOXA1) <- paste("FOXA1_peak", 1:nrow(FOXA1_df), sep="_")
score(FOXA1) <- FOXA1_df[,"X.10.log10.pvalue."] 

# show the first and last lines of the GRanges object
FOXA1
```

# Basic number and statistics of the FOXA1 peaks

Now we have loaded in the FOXA1 peaks and converted into a GRanges object, we can carry out some basic statistical analysis and plot simple visualisations.

## Calculate the number of peaks

The length() function assesses the number of datapoints (peaks) in the FOXA1 object

```{r}
length(FOXA1)
```
## Calculate mean, median, and max size of the peaks

The function width() returns the sizes of all ranges in a GRanges object as vector.

```{r}
FOXA1.size <- width(FOXA1)
summary(FOXA1.size)
```
## Remove all peaks that are larger than 2kb

We can remove unusually large peak widths by assigning a threshold and removing peaks that are larger than it.

```{r}
FOXA1 <- FOXA1[width(FOXA1) <= 2000]

```

Plot the distribution of sizes using the hist() function.

```{r}
hist(width(FOXA1), xlab="FOXA1 peak size", col="gray")
```


What is the distribution of FOXA1 ChIP-seq peak p-values?
We plot the histogram of −log10 transformed p-values. Remember that we stored them in the score column of the GRanges object. We can access them using the function score().

```{r}
# get the -log_10 transformed p-values from the score column
mlPvals <- score(FOXA1)
hist(mlPvals, xlab="-log_10(p-value)", col="gray")
```

###   Read in the ER peaks 

```{r, }


# bed format
ER <- import("data/ER_full.bed", format="bed")
#We fix the name and score columns.

# assign scores by converting the 'name' feald to type numeric
score(ER) <- as.numeric(ER$name)

# overwrite the name column
ER$name <- paste("ER_peaks", 1:length(ER), sep="_")

# use the names() function 
names(ER) <- ER$name 
ER
```

# Compare the peaks of ER and FOXA1

Make a barplot of the number of peaks
```{r}
bp <- barplot(c(length(ER), length(FOXA1)), names=c("ER", "FOXA1"))
# add actual values as text lables to the plot
text(bp, c(length(ER), length(FOXA1)), labels=c(length(ER), length(FOXA1)), pos=1)
```

Use handy function from `ChIPpeakAnno` to calculate the overlaps Then we use the package Vennerable to build a Venn object with the number of peaks in each subset. This object can than be passed to the ‘plot’ function.



## How many ER peaks overlap FOXA1 peaks?
```{r}

# find overlap of binding sites 
ovlHits <- findOverlapsOfPeaks(ER, FOXA1)
ovlHits$venn_cnt
overlaps <- ovlHits$peaklist[["ER///FOXA1"]]

```



```{r}
makeVennDiagram(list(ER, FOXA1), NameOfPeaks=c("ER", "FOXA1"),
                scaled=FALSE, 
                fill=c("#009E73", "#F0E442")) # circle fill color
```

A pie chart is used to demonstrate the overlap features of the common peaks.


```{r}

pie1(table(ovlHits $overlappingPeaks[["ER///FOXA1"]]$overlapFeature))
```



# Functional annotation of ChIP-seq peaks
To understand the function of a transcription factor we want to know to which genes and genomic features it binds.
We will use a TxDb objects. Such an object is an R interface to prefabricated databases contained by specific annotation packages. The package TxDb.Hsapiens.UCSC.hg18.knownGene includes all human genes and transcripts from UCSC with coordinates for the hg18 genome assembly.

```{r}
library(TxDb.Hsapiens.UCSC.hg18.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg18.knownGene # just a shortcut

## create annotation file from EnsDb or TxDb
annoData <- toGRanges(txdb, feature="gene")
annoData[1:2]
rtracklayer::export(annoData, con="TxDb.Hsapiens.UCSC.hg18.gene.bed")
```

Now we overlap the annotation to the peaks
```{r, warning=FALSE}
overlaps_anno <- annotatePeakInBatch(overlaps, AnnotationData=annoData, 
                                    output="overlapping", maxgap=5000L)


aCR<-assignChromosomeRegion(overlaps_anno, nucleotideLevel=FALSE, 
                           precedence=c("Promoters", "immediateDownstream", 
                                         "fiveUTRs", "threeUTRs", 
                                         "Exons", "Introns"), 
                           TxDb=TxDb.Hsapiens.UCSC.hg18.knownGene)
barplot(aCR$percentage)

```

Add the gene names to the annotation and write out as `csv` and `bed` files.

```{r}
library(dplyr)
library(org.Hs.eg.db)
overlaps_anno <- addGeneIDs(overlaps_anno, org.Hs.eg.db, IDs2Add = c("symbol","refseq", "ensembl"), 
feature_id_type = "entrez_id")



as.data.frame(unname(overlaps_anno)) %>% 
  dplyr::select(-peakNames,-peak) %>% 
  readr::write_csv("overlap_peaks_annotated.csv")

names(overlaps_anno) <- lapply(overlaps_anno$peakNames, function(x) paste(x,collapse=":"))
names(overlaps_anno) <- paste(overlaps_anno$feature,names(overlaps_anno),sep="_")


rtracklayer::export(overlaps_anno, con="overlap_peaks.bed")

```

## Enrichment with ChIPpeakAnno
Use functionality within ChIPpeakAnno to perform enrichment (see package vignette).

```{r}
over <- getEnrichedGO(overlaps_anno, orgAnn="org.Hs.eg.db",
                      feature_id_type="entrez_id",
                      maxP = 0.05, minGOterm = 10,
                      multiAdjMethod = "BH",condense = TRUE)
write_csv(over[["bp"]], path = "overlap_peaks_GO.csv")
```

## Enrichment with Reactome

```{r}
library(reactome.db)
path <- getEnrichedPATH(overlaps_anno, "org.Hs.eg.db","reactome.db", maxP = 0.05,feature_id_type="entrez_id" ) %>% 
  rename(ENTREZID = EntrezID)

gene_anno <- AnnotationDbi::select(org.Hs.eg.db, keys = as.character(path$ENTREZID), keytype="ENTREZID",columns="SYMBOL")

path_anno <- AnnotationDbi::select(reactome.db, keys = as.character(path$path.id), 
                                   keytype="PATHID",
                                   columns=c("PATHID","PATHNAME")) %>% rename(path.id = PATHID)

path %>% left_join(gene_anno) %>% 
  group_by(path.id) %>% 
  mutate(Genes = paste(unique(SYMBOL),collapse=";")) %>% 
  ungroup %>% 
  filter(!duplicated(path.id)) %>% 
  left_join(path_anno) %>% 
  distinct %>% 
  select(-ENTREZID, -PATH, -totaltermInDataset, -totaltermInGenome, -SYMBOL)  %>% 
  arrange(pvalue) %>% 
  write_csv("overlap_peaks_reactome.csv")
```


